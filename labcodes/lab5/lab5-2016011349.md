# 练习 1

`load_icode`的前面大部分的工作是将elf格式的执行文件加载到内存中，为其配置vmm，建立用户栈、mm。需要补充的部分只有trapframe的初始化，初始化的方式参照注释即可。

加载用户态应用程序的过程：在用户应用程序加载完毕之后。需要等到调度器选择这个进程占用CPU时，最终调用`proc_run`函数进行上下文切换工作。在切换完成之后，结束进程调度过程，回到用户态执行应用程序的代码。

# 练习 2

只需将父进程的用户内存页一一拷贝到子进程的用户内存空间中。

COW的实现：

- 在`do_fork`时，直接拷贝父进程的页目录表到子进程。
- 只保留`dup_mmap`中拷贝vma链表的部分。弃用`copy_range`。
- 对于所有页增加引用计数1。取消页目录表的写权限，仅保存读权限。
- 在`do_pgfault`中进行额外的处理，在这时进行内存拷贝操作。

# 练习 3

## fork

- 分配新的进程控制块。
- 复制父进程的内存空间。
- 随后分配pid；设置有关信息。
- 设置新进程为`RUNNABLE`。

## exec

- 检查当前进程用户态内存空间是否合法。
- 然后释放虚拟内存空间。
- 调用`load_icode`加载应用程序
- 重新设置当前进程的名字等。

## wait

- 遍历进程列表，找到指定的子进程。
- 如果子进程的状态为`ZOMBIE`，则进行子进程的资源释放工作然后返回。
- 如果子进程的状态不为`ZOMBIE`，则当前进程进入`SLEEPING`状态，调用`schedule`调度自己。

## exit

先释放页表项的物理内存，然后将自己的状态设为`ZOMBIE`并唤醒父进程，等待父进程完成扫尾工作。

## 生命周期图
```
process state changing:
                                            
  alloc_proc                                 RUNNING
      +                                   +--<----<--+
      +                                   + proc_run +
      V                                   +-->---->--+ 
PROC_UNINIT -- proc_init/wakeup_proc --> PROC_RUNNABLE -- try_free_pages/do_wait/do_sleep --> PROC_SLEEPING --
                                           A      +                                                           +
                                           |      +--- do_exit --> PROC_ZOMBIE                                +
                                           +                                                                  + 
                                           -----------------------wakeup_proc----------------------------------
```

proc.c中有。